<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Watercolor Wizard</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        /* Custom scrollbar for a cleaner look */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1; 
        }
        ::-webkit-scrollbar-thumb {
            background: #cbd5e1; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8; 
        }
        
        /* Animation utilities */
        @keyframes fade-in {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .animate-fade-in {
            animation: fade-in 0.2s ease-out;
        }
        @keyframes slide-in-right {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }
        .animate-slide-in-right {
            animation: slide-in-right 0.3s ease-out;
        }
    </style>
</head>
<body class="bg-stone-50 text-slate-800 font-sans selection:bg-blue-100">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo } = React;

        // --- Icons (Inline SVGs to remove external dependencies) ---
        const IconBase = ({ size = 24, className = "", children, ...props }) => (
            <svg 
                xmlns="http://www.w3.org/2000/svg" 
                width={size} 
                height={size} 
                viewBox="0 0 24 24" 
                fill="none" 
                stroke="currentColor" 
                strokeWidth="2" 
                strokeLinecap="round" 
                strokeLinejoin="round" 
                className={className} 
                {...props}
            >
                {children}
            </svg>
        );

        const Droplets = (props) => (
            <IconBase {...props}><path d="M7 16.3c2.2 0 4-1.83 4-4.05 0-1.16-.57-2.26-1.71-3.19S7.29 6.75 7 5.3c-.29 1.45-1.14 2.8-2.29 3.76S3 11.1 3 12.25c0 2.22 1.8 4.05 4 4.05z"/><path d="M12.56 6.6A10.97 10.97 0 0 0 14 3.02c.5 2.5 2 4.9 4 6.5s3 3.5 3 5.5a6.98 6.98 0 0 1-11.91 4.97"/></IconBase>
        );
        const Plus = (props) => (
            <IconBase {...props}><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></IconBase>
        );
        const XIcon = (props) => (
            <IconBase {...props}><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></IconBase>
        );
        const BookOpen = (props) => (
            <IconBase {...props}><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></IconBase>
        );
        const RefreshCw = (props) => (
            <IconBase {...props}><path d="M21 2v6h-6"/><path d="M3 12a9 9 0 0 1 15-6.7L21 8"/><path d="M3 22v-6h6"/><path d="M21 12a9 9 0 0 1-15 6.7L3 16"/></IconBase>
        );

        // --- Color Math Helpers ---

        // Convert Hex to RGB
        const hexToRgb = (hex) => {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        };

        // Convert RGB to Hex
        const rgbToHex = (r, g, b) => {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        };

        // Convert RGB to LAB (Perceptually uniform color space for better distance calculation)
        const rgbToLab = (rgb) => {
            let r = rgb.r / 255, g = rgb.g / 255, b = rgb.b / 255;
            r = (r > 0.04045) ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
            g = (g > 0.04045) ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
            b = (b > 0.04045) ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
            let x = (r * 0.4124 + g * 0.3576 + b * 0.1805) / 0.95047;
            let y = (r * 0.2126 + g * 0.7152 + b * 0.0722) / 1.00000;
            let z = (r * 0.0193 + g * 0.1192 + b * 0.9505) / 1.08883;
            x = (x > 0.008856) ? Math.pow(x, 1/3) : (7.787 * x) + 16/116;
            y = (y > 0.008856) ? Math.pow(y, 1/3) : (7.787 * y) + 16/116;
            z = (z > 0.008856) ? Math.pow(z, 1/3) : (7.787 * z) + 16/116;
            return { L: (116 * y) - 16, a: 500 * (x - y), b: 200 * (y - z) };
        };

        // Calculate deltaE (Color Difference)
        const deltaE = (labA, labB) => {
            const deltaL = labA.L - labB.L;
            const deltaA = labA.a - labB.a;
            const deltaB = labA.b - labB.b;
            return Math.sqrt(deltaL * deltaL + deltaA * deltaA + deltaB * deltaB);
        };

        // Simulate Subtractive Mixing (Approximated)
        const mixColors = (colors, ratios) => {
            let r = 0, g = 0, b = 0;
            let totalRatio = ratios.reduce((a, b) => a + b, 0);
            
            // Normalizing ratios
            const normRatios = ratios.map(r => r / totalRatio);

            // 1. Weighted Average (Additive base)
            let avgR = 0, avgG = 0, avgB = 0;
            colors.forEach((c, i) => {
                avgR += c.rgb.r * normRatios[i];
                avgG += c.rgb.g * normRatios[i];
                avgB += c.rgb.b * normRatios[i];
            });

            // 2. Simplistic "Muddying" Factor
            // Real subtractive mixing is complex (Kubelka-Munk), but for a helper app,
            // we assume mixing paints reduces luminance slightly more than a pure additive average.
            // We dampen the result slightly unless it's mostly white water.
            
            return { r: Math.round(avgR), g: Math.round(avgG), b: Math.round(avgB) };
        };


        // --- Data ---

        const COMMON_PIGMENTS = [
            { id: 'cad-red', name: 'Cadmium Red', hex: '#E30022' },
            { id: 'alizarin', name: 'Alizarin Crimson', hex: '#E32636' },
            { id: 'lemon', name: 'Lemon Yellow', hex: '#FFF44F' },
            { id: 'cad-yellow', name: 'Cadmium Yellow', hex: '#FFF600' },
            { id: 'yellow-ochre', name: 'Yellow Ochre', hex: '#CC7722' },
            { id: 'sap-green', name: 'Sap Green', hex: '#507D2A' },
            { id: 'viridian', name: 'Viridian', hex: '#40826D' },
            { id: 'cobalt', name: 'Cobalt Blue', hex: '#0047AB' },
            { id: 'ultramarine', name: 'Ultramarine', hex: '#4166F5' }, 
            { id: 'burnt-sienna', name: 'Burnt Sienna', hex: '#E97451' },
            { id: 'burnt-umber', name: 'Burnt Umber', hex: '#8A3324' },
            { id: 'paynes', name: 'Payne\'s Grey', hex: '#536878' },
            { id: 'white', name: 'Paper (White)', hex: '#FFFFFF' }, 
        ];

        const INIT_PALETTE = COMMON_PIGMENTS.filter(p => 
            ['cad-red', 'lemon', 'ultramarine', 'burnt-sienna', 'white'].includes(p.id)
        );

        // --- Components ---

        const ColorSwatch = ({ color, size = "md", label, onClick, selected, showRemove, onRemove }) => {
            const sizeClasses = {
                sm: "w-8 h-8",
                md: "w-12 h-12",
                lg: "w-24 h-24",
                xl: "w-full h-32"
            };

            return (
                <div className="flex flex-col items-center group relative">
                    <button 
                        onClick={onClick}
                        className={`${sizeClasses[size]} rounded-full shadow-sm border-2 transition-transform transform active:scale-95 relative overflow-hidden`}
                        style={{ 
                            backgroundColor: color.hex, 
                            borderColor: selected ? '#3b82f6' : 'rgba(0,0,0,0.1)',
                            boxShadow: selected ? '0 0 0 2px #3b82f6' : 'inset 0 2px 4px rgba(0,0,0,0.1)'
                        }}
                    >
                        {/* Watercolor Texture Overlay */}
                        <div className="absolute inset-0 opacity-20 pointer-events-none mix-blend-multiply" 
                             style={{backgroundImage: `url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.5'/%3E%3C/svg%3E")`}}>
                        </div>
                    </button>
                    {label && <span className="text-xs mt-1 text-gray-600 font-medium max-w-[60px] text-center truncate">{label}</span>}
                    
                    {showRemove && (
                        <button 
                            onClick={(e) => { e.stopPropagation(); onRemove(); }}
                            className="absolute -top-1 -right-1 bg-white rounded-full p-1 shadow-md opacity-0 group-hover:opacity-100 transition-opacity hover:bg-red-50 text-red-500"
                        >
                            <XIcon size={12} />
                        </button>
                    )}
                </div>
            );
        };

        const App = () => {
            const [targetHex, setTargetHex] = useState('#8B5A2B'); // Default to a brown
            const [palette, setPalette] = useState(INIT_PALETTE);
            const [showAddModal, setShowAddModal] = useState(false);
            const [showTheory, setShowTheory] = useState(false);
            
            // Derived state for the target
            const targetRgb = useMemo(() => hexToRgb(targetHex), [targetHex]);
            const targetLab = useMemo(() => targetRgb ? rgbToLab(targetRgb) : {L:0,a:0,b:0}, [targetRgb]);

            // --- The Mixing Algorithm ---
            const bestMix = useMemo(() => {
                let bestDist = Infinity;
                let bestRecipe = null;
                let bestResultHex = '#ffffff';

                const paletteWithRgb = palette.map(p => ({ ...p, rgb: hexToRgb(p.hex) }));

                const checkMix = (indices, parts) => {
                    const selectedColors = indices.map(i => paletteWithRgb[i]);
                    const mixedRgb = mixColors(selectedColors, parts);
                    const mixedLab = rgbToLab(mixedRgb);
                    const dist = deltaE(targetLab, mixedLab);

                    if (dist < bestDist) {
                        bestDist = dist;
                        bestResultHex = rgbToHex(mixedRgb.r, mixedRgb.g, mixedRgb.b);
                        bestRecipe = indices.map((idx, i) => ({
                            color: palette[idx],
                            parts: parts[i]
                        }));
                    }
                };

                // 1. Check Single Colors
                for (let i = 0; i < paletteWithRgb.length; i++) {
                    checkMix([i], [1]);
                }

                // 2. Check 2-Color Mixes
                const ratios2 = [[1,1], [2,1], [1,2], [3,1], [1,3], [10,1], [1,10]];
                for (let i = 0; i < paletteWithRgb.length; i++) {
                    for (let j = i + 1; j < paletteWithRgb.length; j++) {
                        for (let r of ratios2) {
                            checkMix([i, j], r);
                        }
                    }
                }

                // 3. Check 3-Color Mixes (Only if error is high)
                if (bestDist > 10) { 
                    const ratios3 = [[1,1,1], [2,1,1], [1,2,1], [1,1,2]];
                    for (let i = 0; i < paletteWithRgb.length; i++) {
                        for (let j = i + 1; j < paletteWithRgb.length; j++) {
                            for (let k = j + 1; k < paletteWithRgb.length; k++) {
                                for (let r of ratios3) {
                                    checkMix([i, j, k], r);
                                }
                            }
                        }
                    }
                }

                return { recipe: bestRecipe, resultHex: bestResultHex, accuracy: Math.max(0, 100 - bestDist * 2) };
            }, [targetHex, palette, targetLab]);

            // Handlers
            const addToPalette = (pigment) => {
                if (!palette.some(p => p.id === pigment.id)) {
                    setPalette([...palette, pigment]);
                }
                setShowAddModal(false);
            };

            const removeFromPalette = (id) => {
                setPalette(palette.filter(p => p.id !== id));
            };

            return (
                <div className="min-h-screen bg-stone-50 pb-20">
                    
                    {/* Header */}
                    <header className="bg-white border-b border-stone-200 sticky top-0 z-20 px-4 py-3 shadow-sm flex items-center justify-between">
                        <div className="flex items-center gap-2">
                            <div className="bg-blue-500 text-white p-2 rounded-lg">
                                <Droplets size={20} />
                            </div>
                            <h1 className="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-600 to-purple-600">
                                Watercolor Wizard
                            </h1>
                        </div>
                        <button 
                            onClick={() => setShowTheory(!showTheory)}
                            className="text-slate-500 hover:text-blue-600 transition-colors"
                            aria-label="Help"
                        >
                            <BookOpen size={24} />
                        </button>
                    </header>

                    <main className="max-w-md mx-auto p-4 space-y-6">

                        {/* 1. Target Selector */}
                        <section className="bg-white rounded-2xl p-6 shadow-sm border border-stone-100">
                            <h2 className="text-sm font-semibold text-slate-400 uppercase tracking-wider mb-4">1. What color do you want?</h2>
                            
                            <div className="flex gap-4 items-center">
                                <div className="relative flex-1">
                                    <input 
                                        type="color" 
                                        value={targetHex}
                                        onChange={(e) => setTargetHex(e.target.value)}
                                        className="opacity-0 absolute inset-0 w-full h-full cursor-pointer z-10"
                                    />
                                    <div 
                                        className="h-24 rounded-xl shadow-inner border border-stone-200 w-full flex items-center justify-center text-white/50 font-medium transition-colors"
                                        style={{ backgroundColor: targetHex }}
                                    >
                                        <span className="drop-shadow-md">Tap to Pick</span>
                                    </div>
                                </div>
                            </div>
                        </section>

                        {/* 2. Palette Management */}
                        <section>
                            <div className="flex items-center justify-between mb-3">
                                <h2 className="text-sm font-semibold text-slate-400 uppercase tracking-wider">2. Your Palette</h2>
                                <button 
                                    onClick={() => setShowAddModal(true)}
                                    className="text-xs bg-stone-100 hover:bg-stone-200 text-stone-600 px-3 py-1 rounded-full font-medium transition-colors"
                                >
                                    + Add Paint
                                </button>
                            </div>

                            <div className="flex flex-wrap gap-3 bg-white p-4 rounded-2xl border border-stone-100 shadow-sm min-h-[100px]">
                                {palette.map(p => (
                                    <ColorSwatch 
                                        key={p.id} 
                                        color={p} 
                                        size="md" 
                                        showRemove={p.id !== 'white'}
                                        onRemove={() => removeFromPalette(p.id)}
                                    />
                                ))}
                                <button 
                                    onClick={() => setShowAddModal(true)}
                                    className="w-12 h-12 rounded-full border-2 border-dashed border-stone-300 flex items-center justify-center text-stone-400 hover:border-blue-400 hover:text-blue-400 transition-colors"
                                >
                                    <Plus size={20} />
                                </button>
                            </div>
                        </section>

                        {/* 3. The Recipe (Results) */}
                        <section className="bg-gradient-to-br from-blue-50 to-indigo-50 rounded-2xl p-6 shadow-md border border-blue-100 relative overflow-hidden">
                            <div className="absolute top-0 right-0 p-4 opacity-5">
                                <Droplets size={100} />
                            </div>
                            
                            <h2 className="text-sm font-semibold text-blue-400 uppercase tracking-wider mb-4 flex items-center gap-2">
                                <RefreshCw size={14} className={bestMix.recipe ? "" : "animate-spin"} />
                                Mixing Recipe
                            </h2>

                            <div className="flex items-center justify-center gap-6 mb-8 relative z-10">
                                {/* Target vs Result Comparison */}
                                <div className="text-center">
                                    <div className="w-16 h-16 rounded-full shadow-sm mb-2 border-2 border-white" style={{backgroundColor: targetHex}}></div>
                                    <span className="text-xs text-slate-500 font-medium">Goal</span>
                                </div>
                                <div className="text-slate-300">âžœ</div>
                                <div className="text-center relative">
                                    <div className="w-16 h-16 rounded-full shadow-sm mb-2 border-2 border-white" style={{backgroundColor: bestMix.resultHex}}></div>
                                    <span className="text-xs text-slate-500 font-medium">Mix Result</span>
                                    {/* Match Score Badge */}
                                    <div className={`absolute -top-2 -right-4 px-2 py-0.5 rounded-full text-[10px] font-bold text-white shadow-sm ${bestMix.accuracy > 90 ? 'bg-green-500' : bestMix.accuracy > 80 ? 'bg-yellow-500' : 'bg-orange-400'}`}>
                                        {Math.round(bestMix.accuracy)}% Match
                                    </div>
                                </div>
                            </div>

                            {/* Recipe Steps */}
                            <div className="space-y-3 bg-white/60 p-4
